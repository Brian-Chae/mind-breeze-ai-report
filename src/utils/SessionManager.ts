import type { EEGDataPoint, PPGDataPoint, ACCDataPoint } from './SimpleCircularBuffer';
import type { ProcessedEEGData } from '../types/eeg';
import JSZip from 'jszip';
import { createSessionStartTime, type TimezoneType } from './timeUtils';
import { StreamingStorageService } from '../services/StreamingStorageService';

// Ï≤òÎ¶¨Îêú PPG Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ
export interface ProcessedPPGData {
  timestamp: number;
  heartRate: number;
  hrv: number;
  spo2?: number;
  signalQuality: number;
}

// Ï≤òÎ¶¨Îêú ACC Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ  
export interface ProcessedACCData {
  timestamp: number;
  magnitude: number;
  activity: number;
  steps?: number;
  orientation: {
    pitch: number;
    roll: number;
    yaw: number;
  };
}

/**
 * ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Ïú†Ìã∏Î¶¨Ìã∞
 */
class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  private metrics: Map<string, {
    totalTime: number;
    executionCount: number;
    maxTime: number;
    lastTime: number;
  }> = new Map();

  static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor();
    }
    return PerformanceMonitor.instance;
  }

  startTimer(label: string): () => void {
    const startTime = performance.now();
    
    return () => {
      const endTime = performance.now();
      const executionTime = endTime - startTime;
      
      this.recordExecution(label, executionTime);
      
      // ÏÑ±Îä• Í≤ΩÍ≥† (50ms Ïù¥ÏÉÅ)
      if (executionTime > 50) {
        console.warn(`‚ö†Ô∏è ${label} took ${executionTime.toFixed(2)}ms`);
      }
    };
  }

  private recordExecution(label: string, executionTime: number): void {
    const existing = this.metrics.get(label) || {
      totalTime: 0,
      executionCount: 0,
      maxTime: 0,
      lastTime: 0
    };

    existing.totalTime += executionTime;
    existing.executionCount++;
    existing.maxTime = Math.max(existing.maxTime, executionTime);
    existing.lastTime = executionTime;

    this.metrics.set(label, existing);
  }

  getMetrics(label: string) {
    const metric = this.metrics.get(label);
    if (!metric) return null;

    return {
      averageTime: metric.totalTime / metric.executionCount,
      maxTime: metric.maxTime,
      lastTime: metric.lastTime,
      executionCount: metric.executionCount
    };
  }

  getAllMetrics() {
    const result: Record<string, any> = {};
    this.metrics.forEach((value, key) => {
      result[key] = {
        averageTime: value.totalTime / value.executionCount,
        maxTime: value.maxTime,
        lastTime: value.lastTime,
        executionCount: value.executionCount
      };
    });
    return result;
  }

  logPerformanceReport(): void {
    console.group('üìä Performance Report');
    this.metrics.forEach((value, key) => {
      const avg = value.totalTime / value.executionCount;
      console.log(`${key}: avg=${avg.toFixed(2)}ms, max=${value.maxTime.toFixed(2)}ms, count=${value.executionCount}`);
    });
    console.groupEnd();
  }
}

// Ï†ÑÏó≠ ÏÑ±Îä• Î™®ÎãàÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§
const performanceMonitor = PerformanceMonitor.getInstance();

/**
 * Phase 1: localStorage Í∏∞Î∞ò ÏÑ∏ÏÖò Í¥ÄÎ¶¨
 * ÎÇòÏ§ëÏóê IndexedDBÎ°ú ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòàÏ†ï
 */

export interface SessionMetadata {
  id: string;
  name: string;
  startTime: Date;
  endTime?: Date;
  duration: number; // seconds
  deviceName: string;
  deviceId: string;
  samplingRate: number;
  dataCount: {
    eeg: number;
    ppg: number;
    acc: number;
    eegProcessed: number;
    ppgProcessed: number;
    accProcessed: number;
  };
  totalSamples?: number; // Ï†ÑÏ≤¥ ÏÉòÌîå Ïàò
  estimatedSize?: number; // Ï∂îÏ†ï ÌååÏùº ÌÅ¨Í∏∞ (bytes)
  notes?: string;
  saveOptions: {
    eegRaw: boolean;
    ppgRaw: boolean;
    accRaw: boolean;
    eegProcessed: boolean;
    ppgProcessed: boolean;
    accProcessed: boolean;
  };
}

export interface SessionData {
  metadata: SessionMetadata;
  eegData: EEGDataPoint[];
  ppgData: PPGDataPoint[];
  accData: ACCDataPoint[];
  systemLogs: string[]; // CSV ÌòïÌÉúÏùò ÏãúÏä§ÌÖú Î°úÍ∑∏
}

export class SessionManager {
  private readonly STORAGE_PREFIX = 'linkband_session_';
  private readonly METADATA_KEY = 'linkband_sessions_metadata';
  private readonly MAX_SESSIONS = 10; // localStorage Ïö©Îüâ Ï†úÌïú
  private readonly MAX_DATA_POINTS = 50000; // ÏÑ∏ÏÖòÎãπ ÏµúÎåÄ Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏

  private currentSession: SessionData | null = null;
  private autoSaveInterval: NodeJS.Timeout | null = null;
  private readonly AUTO_SAVE_INTERVAL = 60000; // 60Ï¥àÎßàÎã§ ÏûêÎèô Ï†ÄÏû• (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
  
  // ÏÑ±Îä• ÏµúÏ†ÅÌôî: Ï¶ùÎ∂Ñ Ï†ÄÏû•ÏùÑ ÏúÑÌïú ÏÉÅÌÉú Ï∂îÏ†Å
  private lastSavedDataCount = {
    eeg: 0,
    ppg: 0,
    acc: 0,
    eegProcessed: 0,
    ppgProcessed: 0,
    accProcessed: 0
  };
  
  // ÏÑ±Îä• ÏµúÏ†ÅÌôî: Ï†ÄÏû• Ïä§Î°úÌãÄÎßÅ
  private isSaving = false;
  private pendingSave = false;

  /**
   * ÏÉà ÏÑ∏ÏÖò ÏãúÏûë
   */
  startSession(
    deviceName: string, 
    deviceId: string, 
    sessionName?: string,
    saveOptions: { eegRaw: boolean; ppgRaw: boolean; accRaw: boolean; eegProcessed: boolean; ppgProcessed: boolean; accProcessed: boolean } = { eegRaw: true, ppgRaw: true, accRaw: true, eegProcessed: true, ppgProcessed: true, accProcessed: true },
    timezone: TimezoneType = 'system'
  ): string {
    // Í∏∞Ï°¥ ÏÑ∏ÏÖòÏù¥ ÏûàÏúºÎ©¥ Ï¢ÖÎ£å
    if (this.currentSession) {
      this.endSession();
    }

    const sessionId = this.generateSessionId();
    const now = createSessionStartTime(timezone);

    const metadata: SessionMetadata = {
      id: sessionId,
      name: sessionName || `Session ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`,
      startTime: now,
      duration: 0,
      deviceName,
      deviceId,
      samplingRate: 250, // LINK BAND Í∏∞Î≥∏Í∞í
      dataCount: {
        eeg: 0,
        ppg: 0,
        acc: 0,
        eegProcessed: 0,
        ppgProcessed: 0,
        accProcessed: 0
      },
      saveOptions
    };

    this.currentSession = {
      metadata,
      eegData: [],
      ppgData: [],
      accData: [],
      systemLogs: []
    };

    // ÏûêÎèô Ï†ÄÏû• ÏãúÏûë
    this.startAutoSave();


    return sessionId;
  }

  /**
   * ÌòÑÏû¨ ÏÑ∏ÏÖò Ï¢ÖÎ£å
   */
  endSession(): boolean {
    if (!this.currentSession) {
      console.warn('Ï¢ÖÎ£åÌï† ÌôúÏÑ± ÏÑ∏ÏÖòÏù¥ ÏóÜÏäµÎãàÎã§');
      return false;
    }

    // Ï¢ÖÎ£å ÏãúÍ∞Ñ ÏÑ§Ï†ï
    const endTime = new Date();
    this.currentSession.metadata.endTime = endTime;
    this.currentSession.metadata.duration = Math.floor(
      (endTime.getTime() - this.currentSession.metadata.startTime.getTime()) / 1000
    );

    // ÏµúÏ¢Ö Ï†ÄÏû•
    this.saveCurrentSession();

    // ÏûêÎèô Ï†ÄÏû• Ï§ëÏßÄ
    this.stopAutoSave();


    this.currentSession = null;

    return true;
  }

  /**
   * EEG Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
   */
  addEEGData(data: EEGDataPoint[]): void {
    if (!this.currentSession || !this.currentSession.metadata.saveOptions.eegRaw) return;

    // Ïö©Îüâ Ï†úÌïú ÌôïÏù∏
    if (this.currentSession.eegData.length + data.length > this.MAX_DATA_POINTS) {
      // Ïò§ÎûòÎêú Îç∞Ïù¥ÌÑ∞ Ï†úÍ±∞ (FIFO)
      const removeCount = this.currentSession.eegData.length + data.length - this.MAX_DATA_POINTS;
      this.currentSession.eegData.splice(0, removeCount);
    }

    this.currentSession.eegData.push(...data);
    this.currentSession.metadata.dataCount.eeg = this.currentSession.eegData.length;
  }

  /**
   * PPG Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
   */
  addPPGData(data: PPGDataPoint[]): void {
    if (!this.currentSession || !this.currentSession.metadata.saveOptions.ppgRaw) return;

    if (this.currentSession.ppgData.length + data.length > this.MAX_DATA_POINTS) {
      const removeCount = this.currentSession.ppgData.length + data.length - this.MAX_DATA_POINTS;
      this.currentSession.ppgData.splice(0, removeCount);
    }

    this.currentSession.ppgData.push(...data);
    this.currentSession.metadata.dataCount.ppg = this.currentSession.ppgData.length;
  }

  /**
   * Í∞ÄÏÜçÎèÑÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
   */
  addACCData(data: ACCDataPoint[]): void {
    if (!this.currentSession || !this.currentSession.metadata.saveOptions.accRaw) return;

    if (this.currentSession.accData.length + data.length > this.MAX_DATA_POINTS) {
      const removeCount = this.currentSession.accData.length + data.length - this.MAX_DATA_POINTS;
      this.currentSession.accData.splice(0, removeCount);
    }

    this.currentSession.accData.push(...data);
    this.currentSession.metadata.dataCount.acc = this.currentSession.accData.length;
  }

  /**
   * Ï≤òÎ¶¨Îêú Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä (ÌïòÏúÑ Ìò∏ÌôòÏÑ±)
   */
  addProcessedData(data: ProcessedEEGData): void {
    // üîß processed Îç∞Ïù¥ÌÑ∞ Î©îÏÜåÎìú Ï†úÍ±∞ - Î≥µÏû°ÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ Ï†úÏô∏
  }

  /**
   * ÏãúÏä§ÌÖú Î°úÍ∑∏ Ï∂îÍ∞Ä
   */
  addSystemLog(logEntry: string): void {
    if (!this.currentSession) return;

    this.currentSession.systemLogs.push(logEntry);

    // ÏãúÏä§ÌÖú Î°úÍ∑∏Îäî Îçî ÎßéÏù¥ Î≥¥Í¥Ä (ÏµúÎåÄ 10000Í∞ú)
    if (this.currentSession.systemLogs.length > 10000) {
      this.currentSession.systemLogs.shift();
    }
  }

  /**
   * ÌòÑÏû¨ ÏÑ∏ÏÖò Ï†ïÎ≥¥ Î∞òÌôò
   */
  getCurrentSession(): SessionData | null {
    return this.currentSession;
  }

  /**
   * Î™®Îì† ÏÑ∏ÏÖò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î∞òÌôò
   */
  getAllSessions(): SessionMetadata[] {
    try {
      const metadataJson = localStorage.getItem(this.METADATA_KEY);
      if (!metadataJson) return [];

      const metadata: SessionMetadata[] = JSON.parse(metadataJson);
      
      // Date Í∞ùÏ≤¥ Î≥µÏõê Î∞è ÎàÑÎùΩÎêú ÌïÑÎìú Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      return metadata.map(session => ({
        ...session,
        startTime: session.startTime ? new Date(session.startTime) : new Date(),
        endTime: session.endTime ? new Date(session.endTime) : undefined,
        duration: session.duration || 0,
        deviceName: session.deviceName || 'Unknown Device',
        deviceId: session.deviceId || 'unknown',
        samplingRate: session.samplingRate || 250,
        dataCount: {
          eeg: session.dataCount?.eeg || 0,
          ppg: session.dataCount?.ppg || 0,
          acc: session.dataCount?.acc || 0,
          eegProcessed: session.dataCount?.eegProcessed || 0,
          ppgProcessed: session.dataCount?.ppgProcessed || 0,
          accProcessed: session.dataCount?.accProcessed || 0
        },
        saveOptions: session.saveOptions || {
          eegRaw: true,
          ppgRaw: true,
          accRaw: true,
          eegProcessed: true,
          ppgProcessed: true,
          accProcessed: true
        }
      }));
    } catch (error) {
      console.error('ÏÑ∏ÏÖò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
      return [];
    }
  }

  /**
   * ÌäπÏ†ï ÏÑ∏ÏÖò Î°úÎìú
   */
  loadSession(sessionId: string): SessionData | null {
    try {
      const sessionJson = localStorage.getItem(this.STORAGE_PREFIX + sessionId);
      if (!sessionJson) {
        console.warn(`ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${sessionId}`);
        return null;
      }

      const sessionData: SessionData = JSON.parse(sessionJson);
      
      // Date Í∞ùÏ≤¥ Î≥µÏõê Î∞è ÎàÑÎùΩÎêú ÌïÑÎìú Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      sessionData.metadata.startTime = sessionData.metadata.startTime ? new Date(sessionData.metadata.startTime) : new Date();
      if (sessionData.metadata.endTime) {
        sessionData.metadata.endTime = new Date(sessionData.metadata.endTime);
      }
      
      // ÎàÑÎùΩÎêú ÌïÑÎìú Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      sessionData.metadata.duration = sessionData.metadata.duration || 0;
      sessionData.metadata.deviceName = sessionData.metadata.deviceName || 'Unknown Device';
      sessionData.metadata.deviceId = sessionData.metadata.deviceId || 'unknown';
      sessionData.metadata.samplingRate = sessionData.metadata.samplingRate || 250;
      
      if (!sessionData.metadata.dataCount) {
        sessionData.metadata.dataCount = {
          eeg: 0,
          ppg: 0,
          acc: 0,
          eegProcessed: 0,
          ppgProcessed: 0,
          accProcessed: 0
        };
      } else {
        sessionData.metadata.dataCount = {
          eeg: sessionData.metadata.dataCount.eeg || 0,
          ppg: sessionData.metadata.dataCount.ppg || 0,
          acc: sessionData.metadata.dataCount.acc || 0,
          eegProcessed: sessionData.metadata.dataCount.eegProcessed || 0,
          ppgProcessed: sessionData.metadata.dataCount.ppgProcessed || 0,
          accProcessed: sessionData.metadata.dataCount.accProcessed || 0
        };
      }
      
      if (!sessionData.metadata.saveOptions) {
        sessionData.metadata.saveOptions = {
          eegRaw: true,
          ppgRaw: true,
          accRaw: true,
          eegProcessed: true,
          ppgProcessed: true,
          accProcessed: true
        };
      }

      // Îç∞Ïù¥ÌÑ∞ Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî (Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Í≤ΩÏö∞)
      if (!sessionData) {
        console.error('ÏÑ∏ÏÖò Îç∞Ïù¥ÌÑ∞Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§');
        return null;
      }
      
      // ÌïÑÏàò Î∞∞Ïó¥Îì§Ïù¥ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥† Ï¥àÍ∏∞Ìôî
      if (!sessionData.eegData) sessionData.eegData = [];
      if (!sessionData.ppgData) sessionData.ppgData = [];
      if (!sessionData.accData) sessionData.accData = [];
      if (!sessionData.systemLogs) sessionData.systemLogs = [];
      
      // üîß processed Îç∞Ïù¥ÌÑ∞ Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî Ï†úÍ±∞ - Î≥µÏû°ÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ Ï†úÏô∏
      
      // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Î∞∞Ïó¥ Í∏∏Ïù¥Î°ú dataCount ÎèôÍ∏∞Ìôî
      sessionData.metadata.dataCount = {
        eeg: sessionData.eegData.length,
        ppg: sessionData.ppgData.length,
        acc: sessionData.accData.length,
        // üîß processed Îç∞Ïù¥ÌÑ∞ Ïπ¥Ïö¥Ìä∏ Ï†úÍ±∞ - Î≥µÏû°ÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ Ï†úÏô∏
        eegProcessed: 0,
        ppgProcessed: 0,
        accProcessed: 0
      };

              console.log(`ÏÑ∏ÏÖò Î°úÎìú ÏôÑÎ£å: ${sessionId}`, {
        dataCount: sessionData.metadata.dataCount,
        actualLengths: {
          eeg: sessionData.eegData.length,
          ppg: sessionData.ppgData.length,
          acc: sessionData.accData.length,
          eegProcessed: 0, // Processed data not stored in SessionData
          ppgProcessed: 0, // Processed data not stored in SessionData
          accProcessed: 0  // Processed data not stored in SessionData
        }
      });
      return sessionData;
    } catch (error) {
      console.error(`ÏÑ∏ÏÖò Î°úÎìú Ïã§Ìå®: ${sessionId}`, error);
      return null;
    }
  }

  /**
   * ÏÑ∏ÏÖò ÏÇ≠Ï†ú
   */
  deleteSession(sessionId: string): boolean {
    try {
      // ÏÑ∏ÏÖò Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
      localStorage.removeItem(this.STORAGE_PREFIX + sessionId);

      // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú Ï†úÍ±∞
      const allSessions = this.getAllSessions();
      const updatedSessions = allSessions.filter(session => session.id !== sessionId);
      this.saveSessionsMetadata(updatedSessions);

  
      return true;
    } catch (error) {
      console.error(`ÏÑ∏ÏÖò ÏÇ≠Ï†ú Ïã§Ìå®: ${sessionId}`, error);
      return false;
    }
  }

  /**
   * CSV ÎÇ¥Î≥¥ÎÇ¥Í∏∞
   */
  exportToCSV(sessionId: string, dataType: 'eeg' | 'ppg' | 'acc' | 'system' = 'eeg'): string | null {
    const session = sessionId === 'current' ? this.currentSession : this.loadSession(sessionId);
    if (!session) {
      console.error('ÎÇ¥Î≥¥ÎÇº ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
      return null;
    }

    try {
      let csvContent = '';

      switch (dataType) {
        case 'eeg':
          csvContent = this.generateEEGCSV(session.eegData, session.metadata);
          break;
        case 'ppg':
          csvContent = this.generatePPGCSV(session.ppgData, session.metadata);
          break;
        case 'acc':
          csvContent = this.generateACCCSV(session.accData, session.metadata);
          break;
        // üîß processed Îç∞Ïù¥ÌÑ∞ ÏºÄÏù¥Ïä§ Ï†úÍ±∞ - Î≥µÏû°ÏÑ±ÏúºÎ°ú Ïù∏Ìï¥ Ï†úÏô∏
        case 'system':
          csvContent = this.generateSystemCSV(session.systemLogs, session.metadata);
          break;
        default:
          throw new Error(`ÏßÄÏõêÎêòÏßÄ ÏïäÎäî Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ: ${dataType}`);
      }

      return csvContent;
    } catch (error) {
      console.error('CSV ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®:', error);
      return null;
    }
  }

  /**
   * Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º ZIP ÌååÏùºÎ°ú Îã§Ïö¥Î°úÎìú
   */
  async downloadAllAsZip(sessionId: string, targetDirHandle?: FileSystemDirectoryHandle): Promise<boolean> {
    console.log(`üîß SessionManager.downloadAllAsZip Ìò∏Ï∂úÎê® - sessionId: ${sessionId}`);
    console.log(`üîß Target directory handle:`, targetDirHandle ? `${targetDirHandle.name}` : 'undefined (Í∏∞Î≥∏ Îã§Ïö¥Î°úÎìú)');
    
    let session: SessionData | null = null;
    
    if (sessionId === 'current') {
      // ÌòÑÏû¨ ÏÑ∏ÏÖòÏùÄ localStorageÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
      session = this.currentSession;
    } else {
      // Ï†ÄÏû•Îêú ÏÑ∏ÏÖòÏùÄ Î®ºÏ†Ä localStorageÏóêÏÑú ÏãúÎèÑ
      session = this.loadSession(sessionId);
      
      if (!session) {
        // localStorageÏóê ÏóÜÏúºÎ©¥ StorageStoreÏóêÏÑú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏ÏôÄÏÑú Í∞ÄÏÉÅ ÏÑ∏ÏÖò ÏÉùÏÑ±
        console.log(`üîß localStorageÏóêÏÑú ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå, StorageStoreÏóêÏÑú Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Í≤ÄÏÉâ: ${sessionId}`);
        try {
          const { useStorageStore } = await import('../stores/storageStore');
          const storageStore = useStorageStore.getState();
          const sessionInfo = storageStore.sessions.find(s => s.id === sessionId);
          
          if (sessionInfo) {
            console.log(`üîß StorageStoreÏóêÏÑú ÏÑ∏ÏÖò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î∞úÍ≤¨: ${sessionInfo.name}`);
            // StorageStore ÏÑ∏ÏÖòÏùÑ SessionData ÌòïÌÉúÎ°ú Î≥ÄÌôò
            session = {
              metadata: {
                id: sessionInfo.id,
                name: sessionInfo.name,
                startTime: new Date(sessionInfo.date + ' ' + sessionInfo.time),
                endTime: undefined, // StorageStoreÏóêÏÑúÎäî endTime Ï†ïÎ≥¥Í∞Ä ÏóÜÏùå
                duration: this.parseDurationString(sessionInfo.duration),
                deviceName: sessionInfo.deviceName || 'Unknown Device',
                deviceId: sessionInfo.deviceId || 'unknown',
                samplingRate: 250,
                dataCount: {
                  eeg: 0,
                  ppg: 0,
                  acc: 0,
                  eegProcessed: 0,
                  ppgProcessed: 0,
                  accProcessed: 0
                },
                saveOptions: {
                  eegRaw: true,
                  ppgRaw: true,
                  accRaw: true,
                  eegProcessed: true,
                  ppgProcessed: true,
                  accProcessed: true
                }
              },
              eegData: [],
              ppgData: [],
              accData: [],
              systemLogs: []
            };
          }
        } catch (error) {
          console.error('‚ùå StorageStoreÏóêÏÑú ÏÑ∏ÏÖò Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
        }
      }
    }
    
    if (!session) {
      console.error('‚ùå SessionManager.downloadAllAsZip - ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
      return false;
    }

    try {
      console.log(`üîß SessionManager.downloadAllAsZip - ÏÑ∏ÏÖò Î∞úÍ≤¨: ${session.metadata.name}`);
      const zip = new JSZip();
      
      // ÏÑ∏ÏÖò Ï†ïÎ≥¥ ÌååÏùº Ï∂îÍ∞Ä
      const sessionInfo = this.generateSessionInfoText(session.metadata);
      zip.file('session_info.txt', sessionInfo);

      // ÏÑ∏ÏÖò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ JSON ÌååÏùº Ï∂îÍ∞Ä
      const metadataJson = JSON.stringify(session.metadata, null, 2);
      zip.file('metadata.json', metadataJson);

      // Raw Îç∞Ïù¥ÌÑ∞ ÌååÏùºÎì§ Ï∂îÍ∞Ä (StorageStore ÏÑ∏ÏÖòÏùò Í≤ΩÏö∞ ÌååÏùº ÏãúÏä§ÌÖúÏóêÏÑú ÌôïÏù∏Ìï¥Ïïº ÌïòÎØÄÎ°ú Ìï≠ÏÉÅ ÏãúÎèÑ)
      const isStorageStoreSession = sessionId !== 'current' && session.eegData.length === 0 && session.ppgData.length === 0 && session.accData.length === 0;
      console.log(`üîß ÏÑ∏ÏÖò ÌÉÄÏûÖ ÌôïÏù∏: ${isStorageStoreSession ? 'StorageStore ÏÑ∏ÏÖò' : 'localStorage ÏÑ∏ÏÖò'}`);
      
      const rawDataTypes: Array<{ type: 'eeg' | 'ppg' | 'acc' | 'system', filename: string, hasData: boolean }> = [
        { type: 'eeg', filename: 'raw-data/eeg_raw_data.csv', hasData: isStorageStoreSession || session.eegData.length > 0 },
        { type: 'ppg', filename: 'raw-data/ppg_raw_data.csv', hasData: isStorageStoreSession || session.ppgData.length > 0 },
        { type: 'acc', filename: 'raw-data/acc_raw_data.csv', hasData: isStorageStoreSession || session.accData.length > 0 },
        { type: 'system', filename: 'system_logs.csv', hasData: isStorageStoreSession || session.systemLogs.length > 0 }
      ];

      // Raw Îç∞Ïù¥ÌÑ∞ ÌååÏùºÎì§ Ï∂îÍ∞Ä (Ïã§Ï†ú Ï†ÄÏû•Îêú ÌååÏùºÎì§ Ïö∞ÏÑ†, ÏóÜÏúºÎ©¥ localStorage Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©)
      await this.addRawDataToZip(zip, session.metadata, rawDataTypes, sessionId);

      // Analytics metrics ÌååÏùºÎì§ Ï∂îÍ∞Ä (StreamingStorageServiceÏóêÏÑú Ï†ÄÏû•Îêú ÌååÏùºÎì§)
      await this.addAnalyticsMetricsToZip(zip, session.metadata);

      // ZIP ÌååÏùº ÏÉùÏÑ±
      const zipBlob = await zip.generateAsync({ type: 'blob' });
      const zipFileName = `${session.metadata.name}_complete_data_${Date.now()}.zip`;

      // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌïú Ìè¥ÎçîÏóê Ï†ÄÏû• ÎòêÎäî Í∏∞Î≥∏ Îã§Ïö¥Î°úÎìú
      if (targetDirHandle) {
        console.log(`üîß ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉù Ìè¥ÎçîÏóê Ï†ÄÏû•: ${targetDirHandle.name}`);
        try {
          // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌïú Ìè¥ÎçîÏóê ZIP ÌååÏùº Ï†ÄÏû•
          const fileHandle = await targetDirHandle.getFileHandle(zipFileName, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(zipBlob);
          await writable.close();
          console.log(`‚úÖ ZIP ÌååÏùºÏù¥ ÏÑ†ÌÉùÌïú Ìè¥ÎçîÏóê Ï†ÄÏû•Îê®: ${zipFileName}`);
        } catch (writeError) {
          console.error('‚ùå ÏÑ†ÌÉùÌïú Ìè¥ÎçîÏóê ÌååÏùº Ï†ÄÏû• Ïã§Ìå®, Í∏∞Î≥∏ Îã§Ïö¥Î°úÎìúÎ°ú ÎåÄÏ≤¥:', writeError);
          // Ìè¥Îçî Ï†ÄÏû• Ïã§Ìå® Ïãú Í∏∞Î≥∏ Îã§Ïö¥Î°úÎìúÎ°ú ÎåÄÏ≤¥
          this.downloadZipBlob(zipBlob, zipFileName);
        }
      } else {
        console.log(`üîß Í∏∞Î≥∏ Îã§Ïö¥Î°úÎìú Ìè¥ÎçîÏóê Ï†ÄÏû•`);
        // Í∏∞Î≥∏ Îã§Ïö¥Î°úÎìú Î∞©Ïãù ÏÇ¨Ïö©
        this.downloadZipBlob(zipBlob, zipFileName);
      }

      console.log('‚úÖ ZIP ÌååÏùº Îã§Ïö¥Î°úÎìú ÏôÑÎ£å');
      return true;
    } catch (error) {
      console.error('ZIP Îã§Ïö¥Î°úÎìú Ïã§Ìå®:', error);
      return false;
    }
  }

  /**
   * ZIP blobÏùÑ Í∏∞Î≥∏ Îã§Ïö¥Î°úÎìú Î∞©ÏãùÏúºÎ°ú Îã§Ïö¥Î°úÎìú
   */
  private downloadZipBlob(zipBlob: Blob, fileName: string): void {
    const link = document.createElement('a');
    const url = URL.createObjectURL(zipBlob);
    link.setAttribute('href', url);
    link.setAttribute('download', fileName);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Analytics metrics ÌååÏùºÎì§ÏùÑ ZIPÏóê Ï∂îÍ∞Ä
   */
  private async addAnalyticsMetricsToZip(zip: JSZip, metadata: SessionMetadata): Promise<void> {
    try {
      console.log('üîß Analytics metrics ÌååÏùºÎì§ÏùÑ ZIPÏóê Ï∂îÍ∞Ä ÏãúÏûë...');
      
      // StorageStoreÏóêÏÑú Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨ Í∞ÄÏ†∏Ïò§Í∏∞
      const { useStorageStore } = await import('../stores/storageStore');
      const storageStore = useStorageStore.getState();
      const storageDirectory = storageStore.config.storageDirectory;
      
      if (!storageDirectory) {
        console.warn('‚ö†Ô∏è Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏñ¥ÏÑú ÏÉòÌîå analytics metrics ÌååÏùº ÏÉùÏÑ±');
        await this.addSampleAnalyticsMetrics(zip, metadata);
        return;
      }

      try {
        // ÏÑ∏ÏÖò ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú Íµ¨ÏÑ±
        const sessionDate = metadata.startTime;
        const year = sessionDate.getFullYear().toString();
        const month = (sessionDate.getMonth() + 1).toString().padStart(2, '0');
        
        // Ïã§Ï†ú Ï†ÄÏû•Îêú analytics metrics ÌååÏùºÎì§ Ï∞æÍ∏∞
        const linkBandDataDir = await storageDirectory.getDirectoryHandle('LinkBand-Data');
        const sessionsDir = await linkBandDataDir.getDirectoryHandle('sessions');
        const yearDir = await sessionsDir.getDirectoryHandle(year);
        const monthDir = await yearDir.getDirectoryHandle(month);
        const sessionDir = await monthDir.getDirectoryHandle(metadata.id);
        const analyticsMetricsDir = await sessionDir.getDirectoryHandle('analysis-metrics');
        
        console.log('üîß Analytics metrics ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÏùå:', analyticsMetricsDir.name);
        
        // analytics-metrics ÎîîÎ†âÌÜ†Î¶¨ ÎÇ¥Ïùò ÌååÏùºÎì§ ÏùΩÍ∏∞
        const analyticsDir = 'analysis-metrics/';
        let filesAdded = 0;
        
        for await (const [name, handle] of (analyticsMetricsDir as any).entries()) {
          if (handle.kind === 'file' && name.endsWith('.csv')) {
            try {
              const file = await handle.getFile();
              const content = await file.text();
              zip.file(analyticsDir + name, content);
              filesAdded++;
              console.log(`‚úÖ Analytics metrics ÌååÏùº Ï∂îÍ∞ÄÎê®: ${name} (${content.length} bytes)`);
            } catch (fileError) {
              console.warn(`‚ö†Ô∏è Analytics metrics ÌååÏùº ÏùΩÍ∏∞ Ïã§Ìå®: ${name}`, fileError);
            }
          }
        }
        
        if (filesAdded === 0) {
          console.warn('‚ö†Ô∏è Analytics metrics ÌååÏùºÏù¥ ÏóÜÏñ¥ÏÑú ÏÉòÌîå ÌååÏùº ÏÉùÏÑ±');
          await this.addSampleAnalyticsMetrics(zip, metadata);
        } else {
          console.log(`‚úÖ ${filesAdded}Í∞úÏùò Ïã§Ï†ú analytics metrics ÌååÏùºÏù¥ ZIPÏóê Ï∂îÍ∞ÄÎê®`);
        }
        
      } catch (dirError) {
        console.warn('‚ö†Ô∏è Analytics metrics ÎîîÎ†âÌÜ†Î¶¨ Ï†ëÍ∑º Ïã§Ìå®, ÏÉòÌîå ÌååÏùº ÏÉùÏÑ±:', dirError);
        await this.addSampleAnalyticsMetrics(zip, metadata);
      }
      
    } catch (error) {
      console.error('‚ùå Analytics metrics ÌååÏùº Ï∂îÍ∞Ä Ïã§Ìå®:', error);
      // Ïò§Î•ò Î∞úÏÉù ÏãúÏóêÎèÑ ÏÉòÌîå ÌååÏùºÏù¥ÎùºÎèÑ Ï∂îÍ∞Ä
      await this.addSampleAnalyticsMetrics(zip, metadata);
    }
  }

  /**
   * Raw data ÌååÏùºÎì§ÏùÑ ZIPÏóê Ï∂îÍ∞Ä (StorageStore ÌååÏùº ÏãúÏä§ÌÖú Ïö∞ÏÑ†)
   */
  private async addRawDataToZip(
    zip: JSZip, 
    metadata: SessionMetadata, 
    rawDataTypes: Array<{ type: 'eeg' | 'ppg' | 'acc' | 'system', filename: string, hasData: boolean }>,
    sessionId: string
  ): Promise<void> {
    try {
      console.log('üîß Raw data ÌååÏùºÎì§ÏùÑ ZIPÏóê Ï∂îÍ∞Ä ÏãúÏûë...');
      
      // StorageStore ÏÑ∏ÏÖòÏù∏ Í≤ΩÏö∞ Ïã§Ï†ú ÌååÏùº ÏãúÏä§ÌÖúÏóêÏÑú CSV ÌååÏùº ÏùΩÍ∏∞ ÏãúÎèÑ
      if (sessionId !== 'current') {
        console.log('üîß StorageStore ÏÑ∏ÏÖò - Ïã§Ï†ú ÌååÏùº ÏãúÏä§ÌÖúÏóêÏÑú CSV ÌååÏùº ÏùΩÍ∏∞ ÏãúÎèÑ');
        const filesAdded = await this.addStorageStoreRawData(zip, metadata, rawDataTypes, sessionId);
        
        if (filesAdded > 0) {
          console.log(`‚úÖ ${filesAdded}Í∞úÏùò Ïã§Ï†ú raw data ÌååÏùºÏù¥ ZIPÏóê Ï∂îÍ∞ÄÎê®`);
          return;
        } else {
          console.warn('‚ö†Ô∏è Ïã§Ï†ú ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏñ¥ÏÑú Îπà CSV ÌååÏùº ÏÉùÏÑ±');
        }
      }
      console.log('üîß Raw data ÌååÏùºÎì§ÏùÑ ZIPÏóê Ï∂îÍ∞Ä ÏãúÏûë...');
      
      // StorageStoreÏóêÏÑú Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨ Í∞ÄÏ†∏Ïò§Í∏∞ (Îçî ÌôïÏã§Ìï®)
      const { useStorageStore } = await import('../stores/storageStore');
      const storageStore = useStorageStore.getState();
      const storageDirectory = storageStore.config.storageDirectory;
      
      if (!storageDirectory) {
        console.warn('‚ö†Ô∏è Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏñ¥ÏÑú localStorage Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©');
        await this.addLocalStorageRawData(zip, rawDataTypes, sessionId);
        return;
      }

      try {
        // ÏÑ∏ÏÖò ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú Íµ¨ÏÑ±
        const sessionDate = metadata.startTime;
        const year = sessionDate.getFullYear().toString();
        const month = (sessionDate.getMonth() + 1).toString().padStart(2, '0');
        
        // Ïã§Ï†ú Ï†ÄÏû•Îêú raw data ÌååÏùºÎì§ Ï∞æÍ∏∞
        const linkBandDataDir = await storageDirectory.getDirectoryHandle('LinkBand-Data');
        const sessionsDir = await linkBandDataDir.getDirectoryHandle('sessions');
        const yearDir = await sessionsDir.getDirectoryHandle(year);
        const monthDir = await yearDir.getDirectoryHandle(month);
        const sessionDir = await monthDir.getDirectoryHandle(metadata.id);
        const rawDataDir = await sessionDir.getDirectoryHandle('raw-data');
        
        console.log('üîß Raw data ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÏùå:', rawDataDir.name);
        
        // raw-data ÎîîÎ†âÌÜ†Î¶¨ ÎÇ¥Ïùò ÌååÏùºÎì§ ÏùΩÍ∏∞
        let filesAdded = 0;
        
        for await (const [name, handle] of (rawDataDir as any).entries()) {
          if (handle.kind === 'file' && name.endsWith('.csv')) {
            try {
              const file = await handle.getFile();
              const content = await file.text();
              zip.file('raw-data/' + name, content);
              filesAdded++;
              console.log(`‚úÖ Raw data ÌååÏùº Ï∂îÍ∞ÄÎê®: ${name} (${content.length} bytes)`);
            } catch (fileError) {
              console.warn(`‚ö†Ô∏è Raw data ÌååÏùº ÏùΩÍ∏∞ Ïã§Ìå®: ${name}`, fileError);
            }
          }
        }
        
        if (filesAdded === 0) {
          console.warn('‚ö†Ô∏è Raw data ÌååÏùºÏù¥ ÏóÜÏñ¥ÏÑú localStorage Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©');
          await this.addLocalStorageRawData(zip, rawDataTypes, sessionId);
        } else {
          console.log(`‚úÖ ${filesAdded}Í∞úÏùò Ïã§Ï†ú raw data ÌååÏùºÏù¥ ZIPÏóê Ï∂îÍ∞ÄÎê®`);
        }
        
      } catch (dirError) {
        console.warn('‚ö†Ô∏è Raw data ÎîîÎ†âÌÜ†Î¶¨ Ï†ëÍ∑º Ïã§Ìå®, localStorage Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©:', dirError);
        await this.addLocalStorageRawData(zip, rawDataTypes, sessionId);
      }
      
    } catch (error) {
      console.error('‚ùå Raw data ÌååÏùº Ï∂îÍ∞Ä Ïã§Ìå®:', error);
      // Ïò§Î•ò Î∞úÏÉù ÏãúÏóêÎèÑ localStorage Îç∞Ïù¥ÌÑ∞ÎùºÎèÑ Ï∂îÍ∞Ä
      await this.addLocalStorageRawData(zip, rawDataTypes, sessionId);
    }
  }

  /**
   * StorageStore ÌååÏùº ÏãúÏä§ÌÖúÏóêÏÑú Ïã§Ï†ú Raw data CSV ÌååÏùºÎì§ÏùÑ ZIPÏóê Ï∂îÍ∞Ä
   */
  private async addStorageStoreRawData(
    zip: JSZip, 
    metadata: SessionMetadata, 
    rawDataTypes: Array<{ type: 'eeg' | 'ppg' | 'acc' | 'system', filename: string, hasData: boolean }>,
    sessionId: string
  ): Promise<number> {
    let filesAdded = 0;
    
    try {
      console.log('üîß StorageStore Raw Data ÏùΩÍ∏∞ ÏãúÏûë...');
      
      // StorageStoreÏóêÏÑú Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨ Ìï∏Îì§ Í∞ÄÏ†∏Ïò§Í∏∞
      const { useStorageStore } = await import('../stores/storageStore');
      const storageStore = useStorageStore.getState();
      const storageDirectory = storageStore.config.storageDirectory;
      
      console.log('üîß StorageStore ÏÉÅÌÉú ÌôïÏù∏:', {
        isInitialized: storageStore.isInitialized,
        storageDirectoryExists: storageDirectory ? 'YES' : 'NO',
        storageDirectoryName: storageDirectory?.name || 'null',
        storageDirectoryPath: storageStore.storageDirectoryPath
      });
      
      if (!storageDirectory) {
        console.warn('‚ö†Ô∏è StorageStoreÏóê Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏùå');
        return 0;
      }
      
      return await this.processStorageDirectory(zip, storageDirectory, metadata, rawDataTypes, sessionId);
      
    } catch (error) {
      console.error('‚ùå StorageStore Raw Data ÏùΩÍ∏∞ Ïã§Ìå®:', error);
      return 0;
    }
  }

  /**
   * Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨ÏóêÏÑú Ïã§Ï†ú ÌååÏùºÎì§ÏùÑ Ï≤òÎ¶¨
   */
  private async processStorageDirectory(
    zip: JSZip,
    storageDirectory: FileSystemDirectoryHandle,
    metadata: SessionMetadata,
    rawDataTypes: Array<{ type: 'eeg' | 'ppg' | 'acc' | 'system', filename: string, hasData: boolean }>,
    sessionId: string
  ): Promise<number> {
    let filesAdded = 0;
    
    try {
      console.log(`üîß Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨ÏóêÏÑú ÏÑ∏ÏÖò ÌååÏùº Ï∞æÍ∏∞ ÏãúÏûë: ${sessionId}`);
      console.log(`üîß Ï†ÄÏû•ÏÜå ÎîîÎ†âÌÜ†Î¶¨ Ïù¥Î¶Ñ: ${storageDirectory.name}`);

      // ÏÑ∏ÏÖò ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú Íµ¨ÏÑ±
      const sessionDate = metadata.startTime;
      const year = sessionDate.getFullYear().toString();
      const month = (sessionDate.getMonth() + 1).toString().padStart(2, '0');
      
      console.log(`üîß ÏÑ∏ÏÖò ÎÇ†Ïßú Ï†ïÎ≥¥: ${year}ÎÖÑ ${month}Ïõî`);
      
      try {
        // Ïã§Ï†ú Ï†ÄÏû•Îêú raw data ÌååÏùºÎì§ Ï∞æÍ∏∞ - Îçî ÏïàÏ†ÑÌïú Î∞©ÏãùÏúºÎ°ú Ï†ëÍ∑º
        let sessionDir: FileSystemDirectoryHandle | null = null;
        
        // Ïó¨Îü¨ Í≤ΩÎ°ú Ìå®ÌÑ¥ ÏãúÎèÑ
        const possiblePaths = [
          ['LinkBand-Data', 'sessions', year, month, sessionId],
          ['sessions', year, month, sessionId],
          [year, month, sessionId],
          [sessionId]
        ];
        
        for (const pathSegments of possiblePaths) {
          try {
            let currentDir = storageDirectory;
            console.log(`üîß Í≤ΩÎ°ú ÏãúÎèÑ: ${pathSegments.join(' -> ')}`);
            
            for (const segment of pathSegments) {
              currentDir = await currentDir.getDirectoryHandle(segment);
              console.log(`üîß ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÏùå: ${segment}`);
            }
            
            sessionDir = currentDir;
            console.log(`üîß ÏÑ∏ÏÖò ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÏùå: ${sessionDir.name}`);
            break;
            
          } catch (pathError) {
            const errorMessage = pathError instanceof Error ? pathError.message : String(pathError);
            console.log(`üîß Í≤ΩÎ°ú Ïã§Ìå®: ${pathSegments.join(' -> ')} - ${errorMessage}`);
            continue;
          }
        }
        
        if (!sessionDir) {
          throw new Error(`ÏÑ∏ÏÖò ÎîîÎ†âÌÜ†Î¶¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: ${sessionId}`);
        }
        
        // raw-data ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÍ∏∞
        let rawDataDir: FileSystemDirectoryHandle | null = null;
        try {
          rawDataDir = await sessionDir.getDirectoryHandle('raw-data');
          console.log('üîß raw-data ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÏùå');
        } catch (error) {
          console.log('üîß raw-data ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏùå, ÏÑ∏ÏÖò Î£®Ìä∏ÏóêÏÑú CSV ÌååÏùº Ï∞æÍ∏∞ ÏãúÎèÑ');
          rawDataDir = sessionDir; // ÏÑ∏ÏÖò Î£®Ìä∏ ÎîîÎ†âÌÜ†Î¶¨ÏóêÏÑú ÏßÅÏ†ë Ï∞æÍ∏∞
        }
        
        // Í∞Å Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖÎ≥ÑÎ°ú Ïã§Ï†ú CSV ÌååÏùº ÏùΩÍ∏∞
        for (const dataType of rawDataTypes) {
          if (!dataType.hasData) continue;
          
          try {
            let csvFileName = '';
            switch (dataType.type) {
              case 'eeg':
                csvFileName = 'eeg_raw_data.csv';
                break;
              case 'ppg':
                csvFileName = 'ppg_raw_data.csv';
                break;
              case 'acc':
                csvFileName = 'acc_raw_data.csv';
                break;
              case 'system':
                csvFileName = 'system_logs.csv';
                break;
            }
            
            const csvFileHandle = await rawDataDir!.getFileHandle(csvFileName);
            const csvFile = await csvFileHandle.getFile();
            const csvContent = await csvFile.text();
            
            if (csvContent.trim()) {
              zip.file(dataType.filename, csvContent);
              filesAdded++;
              console.log(`‚úÖ Ïã§Ï†ú Raw data ÌååÏùº Ï∂îÍ∞ÄÎê®: ${csvFileName} (${csvContent.length} bytes)`);
            } else {
              console.warn(`‚ö†Ô∏è ${csvFileName} ÌååÏùºÏù¥ ÎπÑÏñ¥ÏûàÏùå`);
            }
            
          } catch (fileError) {
            console.warn(`‚ö†Ô∏è ${dataType.type} raw data ÌååÏùº ÏùΩÍ∏∞ Ïã§Ìå®:`, fileError);
          }
        }
        
              } catch (dirError) {
          const errorMessage = dirError instanceof Error ? dirError.message : String(dirError);
          console.warn('‚ö†Ô∏è ÏÑ∏ÏÖò ÎîîÎ†âÌÜ†Î¶¨ Ï†ëÍ∑º Ïã§Ìå®:', errorMessage);
        }
      
    } catch (error) {
      console.error('‚ùå StorageStore raw data ÌååÏùº ÏùΩÍ∏∞ Ïã§Ìå®:', error);
    }
    
    return filesAdded;
  }

  /**
   * localStorageÏóêÏÑú Raw dataÎ•º CSVÎ°ú Î≥ÄÌôòÌïòÏó¨ ZIPÏóê Ï∂îÍ∞Ä (fallback)
   */
  private async addLocalStorageRawData(
    zip: JSZip, 
    rawDataTypes: Array<{ type: 'eeg' | 'ppg' | 'acc' | 'system', filename: string, hasData: boolean }>,
    sessionId: string
  ): Promise<void> {
    console.log(`üîß localStorage Îç∞Ïù¥ÌÑ∞ fallback ÏãúÏûë - sessionId: ${sessionId}`);
    
    // StorageStore ÏÑ∏ÏÖòÏùò Í≤ΩÏö∞ Îπà CSV ÌååÏùºÏù¥ÎùºÎèÑ ÏÉùÏÑ±
    const isStorageStoreSession = sessionId !== 'current';
    
    for (const dataType of rawDataTypes) {
      if (dataType.hasData) {
        const csvContent = this.exportToCSV(sessionId, dataType.type);
        if (csvContent && csvContent.length > 0) {
          zip.file(dataType.filename, csvContent);
          console.log(`‚úÖ ${dataType.filename} ÌååÏùº Ï∂îÍ∞ÄÎê® (localStorage) (${csvContent.length} bytes)`);
        } else if (isStorageStoreSession) {
          // StorageStore ÏÑ∏ÏÖòÏùò Í≤ΩÏö∞ Îπà CSV ÌååÏùºÏù¥ÎùºÎèÑ Ìó§ÎçîÏôÄ Ìï®Íªò ÏÉùÏÑ±
          const emptyCSV = this.generateEmptyCSV(dataType.type);
          zip.file(dataType.filename, emptyCSV);
          console.log(`‚ö†Ô∏è ${dataType.filename} Îπà ÌååÏùº Ï∂îÍ∞ÄÎê® (StorageStore ÏÑ∏ÏÖò)`);
        }
      }
    }
  }

  /**
   * Îπà CSV ÌååÏùº ÏÉùÏÑ± (Ìó§ÎçîÎßå Ìè¨Ìï®)
   */
  private generateEmptyCSV(dataType: 'eeg' | 'ppg' | 'acc' | 'system'): string {
    switch (dataType) {
      case 'eeg':
        return 'timestamp,ch1,ch2,ch3,ch4,ch5,ch6,ch7,ch8,battery,temperature,accelerometer_x,accelerometer_y,accelerometer_z,gyroscope_x,gyroscope_y,gyroscope_z\n';
      case 'ppg':
        return 'timestamp,ppg_red,ppg_ir,ppg_green,ambient_light,temperature\n';
      case 'acc':
        return 'timestamp,x,y,z,magnitude\n';
      case 'system':
        return 'timestamp,event,details\n';
      default:
        return 'timestamp,data\n';
    }
  }

  /**
   * ÏÉòÌîå Analytics metrics ÌååÏùºÎì§ÏùÑ ZIPÏóê Ï∂îÍ∞Ä (fallback)
   */
  private async addSampleAnalyticsMetrics(zip: JSZip, metadata: SessionMetadata): Promise<void> {
    const analyticsDir = 'analysis-metrics/';
    
    // EEG Analytics Metrics ÏÉòÌîå ÏÉùÏÑ±
    const eegAnalyticsHeader = `# LINK BAND EEG Analysis Metrics - Session: ${metadata.name}\n`;
    const eegAnalyticsContent = eegAnalyticsHeader + 
      `timestamp,total_power,emotional_balance,attention,cognitive_load,focus_index,relaxation_index,stress_index,hemispheric_balance,emotional_stability,attention_level,meditation_level,` +
      `ma_total_power,ma_emotional_balance,ma_attention,ma_cognitive_load,ma_focus_index,ma_relaxation_index,ma_stress_index,ma_hemispheric_balance,ma_emotional_stability,ma_attention_level,ma_meditation_level\n`;
    
    // PPG Analytics Metrics ÏÉòÌîå ÏÉùÏÑ±
    const ppgAnalyticsHeader = `# LINK BAND PPG Analysis Metrics - Session: ${metadata.name}\n`;
    const ppgAnalyticsContent = ppgAnalyticsHeader + 
      `timestamp,bpm,sdnn,rmssd,pnn50,lf_power,hf_power,lf_hf_ratio,stress_index,spo2,` +
      `ma_bpm,ma_sdnn,ma_rmssd,ma_pnn50,ma_lf_power,ma_hf_power,ma_lf_hf_ratio,ma_stress_index,ma_spo2\n`;
    
    // ACC Analytics Metrics ÏÉòÌîå ÏÉùÏÑ±  
    const accAnalyticsHeader = `# LINK BAND ACC Analysis Metrics - Session: ${metadata.name}\n`;
    const accAnalyticsContent = accAnalyticsHeader + 
      `timestamp,activity_state,activity_level,stability,avg_movement,std_movement,max_movement,tilt_angle,balance,` +
      `ma_activity_level,ma_stability,ma_avg_movement,ma_std_movement,ma_max_movement,ma_tilt_angle,ma_balance\n`;

    // Analytics metrics ÌååÏùºÎì§ÏùÑ ZIPÏóê Ï∂îÍ∞Ä
    zip.file(analyticsDir + 'eeg-analysis-metrics.csv', eegAnalyticsContent);
    zip.file(analyticsDir + 'ppg-analysis-metrics.csv', ppgAnalyticsContent);
    zip.file(analyticsDir + 'acc-analysis-metrics.csv', accAnalyticsContent);
    
    console.log('‚úÖ ÏÉòÌîå Analytics metrics ÌååÏùºÎì§Ïù¥ ZIPÏóê Ï∂îÍ∞ÄÎê®');
  }

  /**
   * CSV ÌååÏùº Îã§Ïö¥Î°úÎìú
   */
  downloadCSV(sessionId: string, dataType: 'eeg' | 'ppg' | 'acc' | 'system' = 'eeg'): boolean {
    const csvContent = this.exportToCSV(sessionId, dataType);
    if (!csvContent) return false;

    try {
      const session = sessionId === 'current' ? this.currentSession : this.loadSession(sessionId);
      if (!session) return false;

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      
      if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `${session.metadata.name}_${dataType}_${Date.now()}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

  
      return true;
    } catch (error) {
      console.error('CSV Îã§Ïö¥Î°úÎìú Ïã§Ìå®:', error);
      return false;
    }
  }

  /**
   * Ï†ÄÏû•ÏÜå Ïö©Îüâ Ï†ïÎ≥¥
   */
  getStorageInfo(): { used: number; available: number; sessions: number } {
    let used = 0;
    const sessions = this.getAllSessions().length;

    // localStorage ÏÇ¨Ïö©Îüâ Í≥ÑÏÇ∞
    for (let key in localStorage) {
      if (key.startsWith(this.STORAGE_PREFIX) || key === this.METADATA_KEY) {
        used += localStorage[key].length;
      }
    }

    // ÎåÄÎûµÏ†ÅÏù∏ ÏÇ¨Ïö© Í∞ÄÎä• Ïö©Îüâ (5MB Í∞ÄÏ†ï)
    const available = 5 * 1024 * 1024 - used;

    return { used, available, sessions };
  }

  /**
   * Ïò§ÎûòÎêú ÏÑ∏ÏÖò Ï†ïÎ¶¨
   */
  cleanupOldSessions(): void {
    const allSessions = this.getAllSessions();
    
    if (allSessions.length <= this.MAX_SESSIONS) return;

    // ÏãúÏûë ÏãúÍ∞Ñ Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨ (Ïò§ÎûòÎêú Ïàú)
    allSessions.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());

    // Ïò§ÎûòÎêú ÏÑ∏ÏÖòÎì§ ÏÇ≠Ï†ú
    const sessionsToDelete = allSessions.slice(0, allSessions.length - this.MAX_SESSIONS);
    
    for (const session of sessionsToDelete) {
      this.deleteSession(session.id);
    }


  }

  // Private methods

  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateSessionInfoText(metadata: SessionMetadata): string {
    let info = `LINK BAND Session Information\n`;
    info += `================================\n\n`;
    info += `Session Name: ${metadata.name}\n`;
    info += `Session ID: ${metadata.id}\n`;
    info += `Device: ${metadata.deviceName} (${metadata.deviceId})\n`;
    info += `Start Time: ${metadata.startTime.toISOString()}\n`;
    if (metadata.endTime) {
      info += `End Time: ${metadata.endTime.toISOString()}\n`;
    }
    info += `Duration: ${metadata.duration} seconds\n`;
    info += `Sampling Rate: ${metadata.samplingRate} Hz\n\n`;
    
    info += `Data Summary:\n`;
    info += `-------------\n`;
    info += `EEG Raw Data: ${metadata.dataCount.eeg.toLocaleString()} points\n`;
    info += `PPG Raw Data: ${metadata.dataCount.ppg.toLocaleString()} points\n`;
    info += `ACC Raw Data: ${metadata.dataCount.acc.toLocaleString()} points\n`;
    info += `EEG Processed Data: ${metadata.dataCount.eegProcessed.toLocaleString()} points\n`;
    info += `PPG Processed Data: ${metadata.dataCount.ppgProcessed.toLocaleString()} points\n`;
    info += `ACC Processed Data: ${metadata.dataCount.accProcessed.toLocaleString()} points\n\n`;
    
    info += `Save Options:\n`;
    info += `-------------\n`;
    info += `EEG Raw: ${metadata.saveOptions.eegRaw ? 'Enabled' : 'Disabled'}\n`;
    info += `PPG Raw: ${metadata.saveOptions.ppgRaw ? 'Enabled' : 'Disabled'}\n`;
    info += `ACC Raw: ${metadata.saveOptions.accRaw ? 'Enabled' : 'Disabled'}\n`;
    info += `EEG Processed: ${metadata.saveOptions.eegProcessed ? 'Enabled' : 'Disabled'}\n`;
    info += `PPG Processed: ${metadata.saveOptions.ppgProcessed ? 'Enabled' : 'Disabled'}\n`;
    info += `ACC Processed: ${metadata.saveOptions.accProcessed ? 'Enabled' : 'Disabled'}\n\n`;
    
    if (metadata.notes) {
      info += `Notes:\n`;
      info += `------\n`;
      info += `${metadata.notes}\n\n`;
    }
    
    info += `Generated: ${new Date().toISOString()}\n`;
    
    return info;
  }

  private startAutoSave(): void {
    this.stopAutoSave(); // Í∏∞Ï°¥ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    
    this.autoSaveInterval = setInterval(() => {
      const endTimer = performanceMonitor.startTimer('SessionManager.autoSave');
      
      try {
        if (this.currentSession && !this.isSaving) {
          this.saveCurrentSessionOptimized();
        } else if (this.currentSession && this.isSaving) {
          // Ï†ÄÏû• Ï§ëÏù¥Î©¥ Îã§Ïùå Ï£ºÍ∏∞Ïóê Ï†ÄÏû•ÌïòÎèÑÎ°ù ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
          this.pendingSave = true;
        }
      } finally {
        endTimer();
      }
    }, this.AUTO_SAVE_INTERVAL);
  }

  private stopAutoSave(): void {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
      this.autoSaveInterval = null;
    }
    this.pendingSave = false;
  }

  /**
   * ÏÑ±Îä• ÏµúÏ†ÅÌôîÎêú ÏÑ∏ÏÖò Ï†ÄÏû• (Ï¶ùÎ∂Ñ Ï†ÄÏû• + ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨)
   */
  private async saveCurrentSessionOptimized(): Promise<void> {
    if (!this.currentSession || this.isSaving) return;

    const endTimer = performanceMonitor.startTimer('SessionManager.saveOptimized');
    this.isSaving = true;
    
    try {
      // Î≥ÄÍ≤ΩÎêú Îç∞Ïù¥ÌÑ∞Îßå ÌôïÏù∏
      const currentDataCount = {
        eeg: this.currentSession.eegData.length,
        ppg: this.currentSession.ppgData.length,
        acc: this.currentSession.accData.length,
        eegProcessed: 0, // Processed data not stored in SessionData
        ppgProcessed: 0, // Processed data not stored in SessionData
        accProcessed: 0  // Processed data not stored in SessionData
      };

      // Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏóÜÏúºÎ©¥ Ï†ÄÏû• Ïä§ÌÇµ
      const hasChanges = Object.keys(currentDataCount).some(key => 
        currentDataCount[key as keyof typeof currentDataCount] !== 
        this.lastSavedDataCount[key as keyof typeof this.lastSavedDataCount]
      );

      if (!hasChanges) {
        return;
      }
      
      // ÎπÑÎèôÍ∏∞Ï†ÅÏúºÎ°ú Ï†ÄÏû• (Î©îÏù∏ Ïä§Î†àÎìú Î∏îÎ°úÌÇπ Î∞©ÏßÄ)
      await new Promise<void>((resolve, reject) => {
        setTimeout(() => {
          const saveTimer = performanceMonitor.startTimer('SessionManager.localStorage');
          try {
            this.saveCurrentSession();
            
            // Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞ Ïπ¥Ïö¥Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
            this.lastSavedDataCount = { ...currentDataCount };
            
            resolve();
          } catch (error) {
            console.error('ÏÑ∏ÏÖò Ï†ÄÏû• Ïò§Î•ò:', error);
            reject(error);
          } finally {
            saveTimer();
          }
        }, 0);
      });

    } catch (error) {
      console.error('ÏµúÏ†ÅÌôîÎêú ÏÑ∏ÏÖò Ï†ÄÏû• Ïã§Ìå®:', error);
    } finally {
      this.isSaving = false;
      endTimer();
      
      // Ï†ÄÏû• Ï§ëÏóê Ï∂îÍ∞Ä Ï†ÄÏû• ÏöîÏ≤≠Ïù¥ ÏûàÏóàÎã§Î©¥ Îã§Ïùå Ï£ºÍ∏∞Ïóê Ï≤òÎ¶¨
      if (this.pendingSave) {
        this.pendingSave = false;
        setTimeout(() => this.saveCurrentSessionOptimized(), 1000);
      }
    }
  }

  private saveCurrentSession(): void {
    if (!this.currentSession) return;

    try {
      // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (ÏßÄÏÜç ÏãúÍ∞Ñ Í≥ÑÏÇ∞)
      const now = new Date();
      this.currentSession.metadata.duration = Math.floor(
        (now.getTime() - this.currentSession.metadata.startTime.getTime()) / 1000
      );
      
      // Îç∞Ïù¥ÌÑ∞ Ïπ¥Ïö¥Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
      this.currentSession.metadata.dataCount = {
        eeg: this.currentSession.eegData.length,
        ppg: this.currentSession.ppgData.length,
        acc: this.currentSession.accData.length,
        eegProcessed: 0, // Processed data not stored in SessionData
        ppgProcessed: 0, // Processed data not stored in SessionData
        accProcessed: 0  // Processed data not stored in SessionData
      };

      // ÌÅ∞ Îç∞Ïù¥ÌÑ∞ ÏÑ∏Ìä∏Ïùò Í≤ΩÏö∞ ÏïïÏ∂ïÎêú ÌòïÌÉúÎ°ú Ï†ÄÏû• Í≥†Î†§
      const sessionData = this.currentSession;
      const dataSize = JSON.stringify(sessionData).length;
      
      if (dataSize > 5 * 1024 * 1024) { // 5MB Ïù¥ÏÉÅ
        console.warn(`‚ö†Ô∏è ÏÑ∏ÏÖò Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞Í∞Ä ÌÅº: ${(dataSize / 1024 / 1024).toFixed(2)}MB`);
        
        // ÌÅ∞ Îç∞Ïù¥ÌÑ∞Ïùò Í≤ΩÏö∞ ÏµúÏã† Îç∞Ïù¥ÌÑ∞Îßå Ïú†ÏßÄ
        this.trimSessionData(sessionData);
      }

      // ÌòÑÏû¨ ÏÑ∏ÏÖò Ï†ÄÏû•
      const sessionJson = JSON.stringify(sessionData);
      localStorage.setItem(this.STORAGE_PREFIX + sessionData.metadata.id, sessionJson);

      // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
      const allSessions = this.getAllSessions();
      const existingIndex = allSessions.findIndex(s => s.id === sessionData.metadata.id);
      
      if (existingIndex >= 0) {
        allSessions[existingIndex] = sessionData.metadata;
      } else {
        allSessions.push(sessionData.metadata);
      }

      this.saveSessionsMetadata(allSessions);

      // Ïö©Îüâ Í¥ÄÎ¶¨
      this.cleanupOldSessions();

    } catch (error) {
      console.error('ÏÑ∏ÏÖò Ï†ÄÏû• Ïã§Ìå®:', error);
      
      // Ï†ÄÏû• Í≥µÍ∞Ñ Î∂ÄÏ°± Ïãú Ïò§ÎûòÎêú ÏÑ∏ÏÖò Ï†ïÎ¶¨
      if (error instanceof Error && error.name === 'QuotaExceededError') {
        this.cleanupOldSessions();
        // Ïû¨ÏãúÎèÑ
        try {
          const sessionJson = JSON.stringify(this.currentSession);
          localStorage.setItem(this.STORAGE_PREFIX + this.currentSession.metadata.id, sessionJson);
        } catch (retryError) {
          console.error('ÏÑ∏ÏÖò Ï†ÄÏû• Ïû¨ÏãúÎèÑ Ïã§Ìå®:', retryError);
        }
      }
    }
  }

  /**
   * ÏßÄÏÜçÏãúÍ∞Ñ Î¨∏ÏûêÏó¥ÏùÑ Ï¥à Îã®ÏúÑÎ°ú Î≥ÄÌôò
   */
  private parseDurationString(durationStr: string): number {
    if (!durationStr) return 0;
    
    // "16Ï¥à", "1Î∂Ñ 30Ï¥à", "1ÏãúÍ∞Ñ 5Î∂Ñ" Îì±Ïùò ÌòïÌÉúÎ•º ÌååÏã±
    const timeUnits = [
      { unit: 'ÏãúÍ∞Ñ', multiplier: 3600 },
      { unit: 'Î∂Ñ', multiplier: 60 },
      { unit: 'Ï¥à', multiplier: 1 }
    ];
    
    let totalSeconds = 0;
    
    for (const { unit, multiplier } of timeUnits) {
      const regex = new RegExp(`(\\d+)${unit}`);
      const match = durationStr.match(regex);
      if (match) {
        totalSeconds += parseInt(match[1]) * multiplier;
      }
    }
    
    return totalSeconds || 0;
  }

  /**
   * ÌÅ∞ ÏÑ∏ÏÖò Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ (Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî)
   */
  private trimSessionData(sessionData: SessionData): void {
    const maxPoints = 10000; // Í∞Å Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖÎãπ ÏµúÎåÄ Ìè¨Ïù∏Ìä∏ Ïàò
    
    if (sessionData.eegData.length > maxPoints) {
      sessionData.eegData = sessionData.eegData.slice(-maxPoints);
    }
    if (sessionData.ppgData.length > maxPoints) {
      sessionData.ppgData = sessionData.ppgData.slice(-maxPoints);
    }
    if (sessionData.accData.length > maxPoints) {
      sessionData.accData = sessionData.accData.slice(-maxPoints);
    }
    // Processed data not stored in SessionData - no trimming needed
  }

  private saveSessionsMetadata(sessions: SessionMetadata[]): void {
    try {
      const metadataJson = JSON.stringify(sessions);
      localStorage.setItem(this.METADATA_KEY, metadataJson);
    } catch (error) {
      console.error('ÏÑ∏ÏÖò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïã§Ìå®:', error);
    }
  }

  private generateEEGCSV(data: EEGDataPoint[], metadata: SessionMetadata): string {
    let csv = `# LINK BAND EEG Data Export\n`;
    csv += `# Session: ${metadata.name}\n`;
    csv += `# Device: ${metadata.deviceName} (${metadata.deviceId})\n`;
    csv += `# Start Time: ${metadata.startTime.toISOString()}\n`;
    csv += `# Duration: ${metadata.duration}s\n`;
    csv += `# Sampling Rate: ${metadata.samplingRate}Hz\n`;
    csv += `# Data Points: ${data.length}\n`;
    csv += `#\n`;
    csv += `timestamp,fp1,fp2\n`;

    for (const point of data) {
      csv += `${point.timestamp},${point.fp1},${point.fp2}\n`;
    }

    return csv;
  }

  private generatePPGCSV(data: PPGDataPoint[], metadata: SessionMetadata): string {
    let csv = `# LINK BAND PPG Data Export\n`;
    csv += `# Session: ${metadata.name}\n`;
    csv += `timestamp,red,ir\n`;

    for (const point of data) {
      csv += `${point.timestamp},${point.red},${point.ir}\n`;
    }

    return csv;
  }

  private generateACCCSV(data: ACCDataPoint[], metadata: SessionMetadata): string {
    let csv = `# LINK BAND Accelerometer Data Export\n`;
    csv += `# Session: ${metadata.name}\n`;
    csv += `timestamp,x,y,z\n`;

    for (const point of data) {
      csv += `${point.timestamp},${point.x},${point.y},${point.z}\n`;
    }

    return csv;
  }

  private generateProcessedEEGCSV(data: ProcessedEEGData[], metadata: SessionMetadata): string {
    let csv = `# LINK BAND Processed EEG Data Export\n`;
    csv += `# Session: ${metadata.name}\n`;
    csv += `timestamp,delta,theta,alpha,beta,gamma,signal_quality,brain_state,confidence\n`;

    for (const point of data) {
      csv += `${point.timestamp},${point.bandPowers.delta},${point.bandPowers.theta},${point.bandPowers.alpha},${point.bandPowers.beta},${point.bandPowers.gamma},${point.signalQuality.overall},${point.brainState.currentState},${point.brainState.confidence}\n`;
    }

    return csv;
  }

  private generateProcessedPPGCSV(data: ProcessedPPGData[], metadata: SessionMetadata): string {
    let csv = `# LINK BAND Processed PPG Data Export\n`;
    csv += `# Session: ${metadata.name}\n`;
    csv += `timestamp,heart_rate,hrv,spo2,signal_quality\n`;

    for (const point of data) {
      csv += `${point.timestamp},${point.heartRate},${point.hrv},${point.spo2},${point.signalQuality}\n`;
    }

    return csv;
  }

  private generateProcessedACCCSV(data: ProcessedACCData[], metadata: SessionMetadata): string {
    let csv = `# LINK BAND Processed Accelerometer Data Export\n`;
    csv += `# Session: ${metadata.name}\n`;
    csv += `timestamp,magnitude,activity,steps,pitch,roll,yaw\n`;

    for (const point of data) {
      csv += `${point.timestamp},${point.magnitude},${point.activity},${point.steps},${point.orientation.pitch},${point.orientation.roll},${point.orientation.yaw}\n`;
    }

    return csv;
  }

  private generateSystemCSV(logs: string[], metadata: SessionMetadata): string {
    let csv = `# LINK BAND System Logs Export\n`;
    csv += `# Session: ${metadata.name}\n`;
    csv += `# Log Entries: ${logs.length}\n`;
    csv += `#\n`;

    for (const log of logs) {
      csv += log + '\n';
    }

    return csv;
  }

  /**
   * ÏÑ±Îä• Î¶¨Ìè¨Ìä∏ Ï∂úÎ†•
   */
  getPerformanceReport() {
    return performanceMonitor.getAllMetrics();
  }

  /**
   * ÏÑ±Îä• Î¶¨Ìè¨Ìä∏ Î°úÍπÖ
   */
  logPerformanceReport(): void {
    performanceMonitor.logPerformanceReport();
  }
}

// Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
export const sessionManager = new SessionManager(); 